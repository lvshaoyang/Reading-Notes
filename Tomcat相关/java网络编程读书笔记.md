2017-07-16
    
    Tomcat剖析时用到好些java网络编程方面的知识。学习一上此书。
    网络传输数据，就是协议！！！
    就按规定的协议来，不管什么厂家什么品牌都按同一个方法进行解析。
    对于HTTP协议，TCP/IP协议不行，就是不懂，希望你坚持下去吧，用7年的时间去成长起来。
Chapter One  基本网络概念

    基本网络概念这正是我欠缺的！！！！
    1、用C和C++也可以编写应用层网络软件，用Java只是更简单。
    那么用C怎么编写呢？可以学习一下。
    2、文章介绍了线程和流，这两内容几乎对所有的网络程序都到头重要，但是我却不熟悉！！书还是要看，不然就是没收获，别看买了那么多，而且还要不止一遍的读。
    3、那么关于网络相关的程序有哪些呢？如一些经典的应用程序，如电子邮件、Web浏览器和远程登录，另外大多数也有音乐播放器，多人游戏等。
    4、Java编写网络程序比其它语言都简单得多。Java应用程序通过Internet发送和接收数据都很容易。
    5、到底什么是以太网？？
    6、现代计算机网络都是包交换（分组交换）网络：流经网络的数据分割成小块，称为包（packet,也称分组），每个包都单独加以处理。每个包都包含了由谁发送和将发往何处的信息。将数据分成单独的带有地址的包，其最重要的优点是，多个即将交换的包可以在一条线缆上传输。
    7、计算机来回传递数据需要遵循协议（protocol）
    8、TCP/IP四层模型：从上到下：应用层（如Firefox）—>传输层(TCP,UDP)->网际层（IP）->主机网络层（以太网，WIFI,LTE等）。
    网际层协议定义了数据位和字节如何组织为更大的分组，称为包，还定义了寻址机制。网际协议（IP）是世界上使用最广泛的网络层协议。另外网际层支持不同类型的主机网络层相互对话。Internet路由器会完成WIFI和Ethernet,DSL等协议之间的转换。
    传输层负责确保各包以发送的顺序接收，并保证没有数据丢失或者破坏。这一层主要有两个协议，TCP和UDP
    应用层：主机网络层，网际层，传输层共同定义了数据如何从一台计算机传输到另一台计算机。应用层则确定了数据传输后的操作。如：Web的HTTP协议，电子邮件的SMTP,POP,IMAP,用于文件传输的FTP,FSP和TFTP；用于文件访问的NFS；
    9、在网际层（IP）上可以运行很多其他协议。最常用的是ICMP，internet control message protocol,如ping程序。TCP,UDP也是。但是java只支持TCP和UDP,以及建立在他们之上的协议。
2017-07-17
    
    1、有些地址区块和模式很特殊。以10.、172.16.、172.31.、和192.168.开头的所有IPv4地址都未分配。这些地址可以在内部网使用，但是使用这些地址的主机不允许加入全球Internet。
    2、以前自己不理解的IP到底是怎么回事，到底是怎么数据传输的，今天这一点可能给我一些启迪。是什么呢？
    网络地址转换(Network Address Translation,NAT)：基于NAT的网络中，大多数节点只有不可路由的本地地址，这些地址可能从10.x.x.x、172.16.x.x到172.31.x.x，或者192.168.x.x选择。将本地网络连接到ISP的路由器会把这些本地地址转换为更小的一组可路由的地址。
    例如：公寓里有十来个IP节点，它们都共用一个外部可见的IP地址。我现在用的计算机的IP地址是192.168.1.5，不过，在你的网络上这个地址可能指示一个完全不同的主机。另外，你也无法向192.168.1.5发送数据到达我的计算机。实际上，必须把数据发送到216.254.85.72（即使这样，只有当把NAT路由器配置为将入站连接到192.168.1.5时，数据才会真正送达我的计算机）。
    路由器会监视出站和入站连接，调整IP包中的地址。对于出站的包，它将源地址改为路由器的外部地址（我的网络上这是216.254.85.72）。对于入站的包，它将目的地址改为一个本地地址，如192.168.1.12。它怎么知道要发给内部的12呢?这个还不是很清楚。如果IPv6流行起来，那么NAT就没意义了，因为一个机器一个iP.
    问题：如果我 是192.168.1.5我要访问局域网的192.168.1.10路由到外网再回来？？？
    另外路由是什么？

Chapter 2
    
    1、Java中输入和输出（I/O）的组织与其它大多数语言如C，C++都不一样。那么C的输入输出怎么弄呢？
    2、Java独特的I/O方法：输入流读取数据，输出流写入数据。不同的流类，如java.io.FileInputStream和sun.net.TelnetOutputStream会读/写某个特定的数据源。但是都是相同的基本方法。
    关于流的缓存：
    3、输入流有一个write(int b)方法，一次写入一个字节通常效率不高。如：流出以太网卡的每个TCP分片包含至少40字节的开销用于路由和纠错。如果每字节单独发送，那么实际填入到网络中的数据可能会高出41倍以上！因此TCP/IP实现都会在某种程度上缓存数据。也就是说，它们在内存中积累数据字节，只有积累到一定量的数据后，或者经过了一定的时间后，才将所积累的数据发送到最终目的地。但是如果要发送多字节，可以使用write(byte[] data)通常比一次写入data数组中的一字节要快的多。与write(int b)的区别就是：这些字节在写入网络之前先打包到一个字节数组中。数组满了之后自动输出吗？？
    4、与在网络硬件中缓存一样，流还可以在软件中缓存，即直接用Java代码缓存。可通过BufferedOutputStream或BufferedWriter封装底层流来实现。使用缓冲流时，在写入数据完成后，刷新(flush)输出流很重要。如果输出流有一个1024字节缓冲区，那这个流在发送缓冲区的数据前还等待更多的数据到达 ，就一直不输出，flush()可以强迫缓冲的流发送数据，即使缓冲区没满，以此来打破这种死锁状态。
    5、缓冲流在JVM中是怎么样的一种存在呢？？
    6、过滤流怎么使用呢，是用哪个流的读/写方法呢？
    例如：
        FileInputStream fin = new FileInputStream("data.txt");
        BufferedInputStream bin = new BufferedInputStream(fin);
        那么问题来了，可能会使用fin的read()方法，那么声明的bin还有什么用呢？多态的好处在这时候就可以看出来了，可以写成如下这样：
        InputStream in = new FileInputStream("data.txt");
        in = new BufferedInputStream(in);
        直接使用in就可以了，而且还是封装后的流。
    如果必须使用父类中没有声明的过滤器流的方法，可以直接在一个流中构造另一个流，如：
        DataOutputStream out = new DataOutputStream(
        new BufferedOutputStream(
        new FileOutputStream("data.txt")));
        就可以使用DataOutputStream中独有的方法了。
