2017-07-16
    
    Tomcat剖析时用到好些java网络编程方面的知识。学习一下此书。
    网络传输数据，就是协议！！！
    就按规定的协议来，不管什么厂家什么品牌都按同一个方法进行解析。
    对于HTTP协议，TCP/IP协议不行，就是不懂，希望你坚持下去吧，用_7_年的时间去成长起来。
Chapter One  基本网络概念

    基本网络概念这正是我欠缺的！！！！
    1、用C和C++也可以编写应用层网络软件，用Java只是更简单。
    那么用C怎么编写呢？可以学习一下。
    2、文章介绍了线程和流，这两内容几乎对所有的网络程序都到头重要，但是我却不熟悉！！书还是要看，不然就是没收获，别看买了那么多，而且还要不止一遍的读。
    3、那么关于网络相关的程序有哪些呢？如一些经典的应用程序，如电子邮件、Web浏览器和远程登录，另外大多数也有音乐播放器，多人游戏等。
    4、Java编写网络程序比其它语言都简单得多。Java应用程序通过Internet发送和接收数据都很容易。
    5、到底什么是以太网？？
    6、现代计算机网络都是包交换（分组交换）网络：流经网络的数据分割成小块，称为包（packet,也称分组），每个包都单独加以处理。每个包都包含了由谁发送和将发往何处的信息。将数据分成单独的带有地址的包，其最重要的优点是，多个即将交换的包可以在一条线缆上传输。
    7、计算机来回传递数据需要遵循协议（protocol）
    8、TCP/IP四层模型：从上到下：应用层（如Firefox）—>传输层(TCP,UDP)->网际层（IP）->主机网络层（以太网，WIFI,LTE等）。
    网际层协议定义了数据位和字节如何组织为更大的分组，称为包，还定义了寻址机制。网际协议（IP）是世界上使用最广泛的网络层协议。另外网际层支持不同类型的主机网络层相互对话。Internet路由器会完成WIFI和Ethernet,DSL等协议之间的转换。
    传输层负责确保各包以发送的顺序接收，并保证没有数据丢失或者破坏。这一层主要有两个协议，TCP和UDP
    应用层：主机网络层，网际层，传输层共同定义了数据如何从一台计算机传输到另一台计算机。应用层则确定了数据传输后的操作。如：Web的HTTP协议，电子邮件的SMTP,POP,IMAP,用于文件传输的FTP,FSP和TFTP；用于文件访问的NFS；
    9、在网际层（IP）上可以运行很多其他协议。最常用的是ICMP，internet control message protocol,如ping程序。TCP,UDP也是。但是java只支持TCP和UDP,以及建立在他们之上的协议。
2017-07-17
    
    1、有些地址区块和模式很特殊。以10.、172.16.、172.31.、和192.168.开头的所有IPv4地址都未分配。这些地址可以在内部网使用，但是使用这些地址的主机不允许加入全球Internet。
    2、以前自己不理解的IP到底是怎么回事，到底是怎么数据传输的，今天这一点可能给我一些启迪。是什么呢？
    网络地址转换(Network Address Translation,NAT)：基于NAT的网络中，大多数节点只有不可路由的本地地址，这些地址可能从10.x.x.x、172.16.x.x到172.31.x.x，或者192.168.x.x选择。将本地网络连接到ISP的路由器会把这些本地地址转换为更小的一组可路由的地址。
    例如：公寓里有十来个IP节点，它们都共用一个外部可见的IP地址。我现在用的计算机的IP地址是192.168.1.5，不过，在你的网络上这个地址可能指示一个完全不同的主机。另外，你也无法向192.168.1.5发送数据到达我的计算机。实际上，必须把数据发送到216.254.85.72（即使这样，只有当把NAT路由器配置为将入站连接到192.168.1.5时，数据才会真正送达我的计算机）。
    路由器会监视出站和入站连接，调整IP包中的地址。对于出站的包，它将源地址改为路由器的外部地址（我的网络上这是216.254.85.72）。对于入站的包，它将目的地址改为一个本地地址，如192.168.1.12。它怎么知道要发给内部的12呢?这个还不是很清楚。如果IPv6流行起来，那么NAT就没意义了，因为一个机器一个iP.
    问题：如果我 是192.168.1.5我要访问局域网的192.168.1.10路由到外网再回来？？？
    另外路由是什么？

Chapter 2
    
    1、Java中输入和输出（I/O）的组织与其它大多数语言如C，C++都不一样。那么C的输入输出怎么弄呢？
    2、Java独特的I/O方法：输入流读取数据，输出流写入数据。不同的流类，如java.io.FileInputStream和sun.net.TelnetOutputStream会读/写某个特定的数据源。但是都是相同的基本方法。
    关于流的缓存：
    3、输入流有一个write(int b)方法，一次写入一个字节通常效率不高。如：流出以太网卡的每个TCP分片包含至少40字节的开销用于路由和纠错。如果每字节单独发送，那么实际填入到网络中的数据可能会高出41倍以上！因此TCP/IP实现都会在某种程度上缓存数据。也就是说，它们在内存中积累数据字节，只有积累到一定量的数据后，或者经过了一定的时间后，才将所积累的数据发送到最终目的地。但是如果要发送多字节，可以使用write(byte[] data)通常比一次写入data数组中的一字节要快的多。与write(int b)的区别就是：这些字节在写入网络之前先打包到一个字节数组中。数组满了之后自动输出吗？？
    4、与在网络硬件中缓存一样，流还可以在软件中缓存，即直接用Java代码缓存。可通过BufferedOutputStream或BufferedWriter封装底层流来实现。使用缓冲流时，在写入数据完成后，刷新(flush)输出流很重要。如果输出流有一个1024字节缓冲区，那这个流在发送缓冲区的数据前还等待更多的数据到达 ，就一直不输出，flush()可以强迫缓冲的流发送数据，即使缓冲区没满，以此来打破这种死锁状态。
    5、缓冲流在JVM中是怎么样的一种存在呢？？
    6、过滤流怎么使用呢，是用哪个流的读/写方法呢？
    例如：
        FileInputStream fin = new FileInputStream("data.txt");
        BufferedInputStream bin = new BufferedInputStream(fin);
        那么问题来了，可能会使用fin的read()方法，那么声明的bin还有什么用呢？多态的好处在这时候就可以看出来了，可以写成如下这样：
        InputStream in = new FileInputStream("data.txt");
        in = new BufferedInputStream(in);
        直接使用in就可以了，而且还是封装后的流。
    如果必须使用父类中没有声明的过滤器流的方法，可以直接在一个流中构造另一个流，如：
        DataOutputStream out = new DataOutputStream(
        new BufferedOutputStream(
        new FileOutputStream("data.txt")));
        就可以使用DataOutputStream中独有的方法了。
2017-07-18
    
    数据流：DataInputStream和DataOutputStream类
    可以用来写入特定的Java数据类型。
    第2章的后半部分草草看了看，如果后面使用到相应的流了可以回头看看。

Chapter 3
    线程
    
        1、又来到了线程。通过使用线程池而不是为每个连接生成新线程，会大大提高服务器的性能。还是老问题，到底线程池是怎么样的一种存在呢？？
        2、在虚拟机中执行的线程与虚拟机构造的Thread对象之间存在一种一一对应的关系。
        3、理解线程中的run()方法：应当把线程要做的所有工作都放在这个方法中，这个方法可以调用其他方法，可以构造其他对象，甚至可以生成其他线程。线程要在这里启动，并在这里结束。run()方法完成时，线程也就消失了。并且无法接受参数或者返回值。
        4、一个小程序，为指定文件生成一个256位的SHA-2消息摘要，这个有啥用？？
2017-07-19
    
    1、如果使用传统的Runnable线程，怎么获取相应的返回值呢？
    使用回调，就是主线种中有一个方法，可以在线程将要结束的时候，调用这个方法，获取线程的结果。
    那么回调的意思是啥呢？比如我在一个类A的主线程里main()中调用了一个线程，我在线程中如果使用了这个类A的实例方法，那么就称为回调，因为是线程在完成时反过来调用其创建都者。
    回调在Swing，awt，中常用。回调机制有一个更一般的名字：观察者（Observer）模式。
    2、问题：
        在java中有数据库连接池，有线程池，都是为了避免创建新的连接，减少服务器消耗的一种存在，那么这些连接是怎么样的一种存在呢？他们凭什么一直维持着连接状态呢？底层是怎么样的一种实现呢？
    3、关于Future,Callable和Executor
    java5引入了多线程编程的一个新方法，通过隐藏细节可以更容易地处理回调。不再是直接创建一个线程，你要创建一个ExecutorService，它会根据需要为你创建线程，可以向ExecutorService提交Callable任务，对于每个Callable任务，会分别得到一个Future。之后可以向Future请求得到任务的结果。如果结果已准备就绪，就会立即得到这个结果，如果还未准备好，轮询线程会阻塞，直到结果准备就绪。可以创建很多线程，然后按需要的顺序得到你需要的答案。
    Executors负责创建ExecutorService
    ExecutorService负责执行线程，submit(Callable c)方法，并且返回Future对象，Future对象包含线程返回值，通过get()方法获得。
2017-07-20
    
    同步：到底是对谁同步？同一个对象?
    同步要求在同一个对象上同步的所有代码要连续地运行，而不能并行运行。例如：如果另一个不同的类和不同进程中的代码恰好对System.out同步，那么它也不能与这个代码块并行运行。
    synchronized(System.out){
        System.out.print(input + ":");
        System.out.print("*****");
        System.out.println();
    }不懂
    2、只有当两个线程都拥有相同对象的引用时，同步才成为问题。比如我声明了一个对象在A类中，两个线程t1,t2中都调用了这个实例，那么就是同步了。
    3、选择对哪个对象同步很重要。可以对引用对象本身同步，也就是this关键词。
    4、怎么减少同步呢？第一个办法：在可能的情况下，尽可能的使用局部变量而不是字段。局部变量不存在同步问题，每次进入一个方法时，虚拟机将为这个方法创建一组全新的局部变量。这些变量在方法外部是不可见的，而且方法退出时被撤销。因此一个局部变量不可能由两个不同的线程共享。二、基本类型的方法参数也可以在单独的线程中安全地修改。因为java按值而不是引用来传递参数。
    对象类型的方法参数有些麻烦，因为按值传递的实际参数是对象的引用。假设将一个数组的引用传入sort()方法，当这个方法对数组排序时，没有办法阻止同样由这个数组引用的其他线程修改数组中的值。
    5、java.util.concurrent.atomic中的类到底怎么用呢？
    6、怎么形成一个死锁？
    比如我有一个类A，A中有两个方法，a()，b(),两个都是同步的方法，a()中会调用 b（）方法，b()中也会调用a（）方法，如果一个线程t1调用了a()方法，然后阻塞，另一个线程t2调用了b（）方法，然后阻塞，t1解除阻塞后继续执行a（）方法，然后调用b（）方法，但是b()被t2上锁了，同样的t2所需要的a也被上锁了，那么两个就死锁了。
    
🇨🇳2017-07-21

了解JVM对学习线程很有用啊！！
    
    线程的调度，可以通过优先级。
    问题来了：阻塞是什么？？
    任何时候线程必须停下来等待它没有的资源时，就会发生阻塞。要让网络程序中的线程自动放弃CPU控制权，最常见的方式是对I/O阻塞。由于CPU比网络和磁盘快得多，网络程序经常会在等待数据从网络到达或向网络发送数据时阻塞。
    join()方法，是要被调用的一个线程实例加入到当前线程中去。

理解线程池的机会来了：

    线程池和Executor：向程序添加多个线程极大地提升性能尤其是I/O受限的程序。但是，但是线程自身也存在开销，启动一个线程时，以及线程撤销后进行清理时，都需要虚拟机做大量工作，尤其是生成数到百个线程的程序。更重要的是，在运行线程之间切换也会带来开销。
    那么线程池就会有帮助了，利用java.util.concurrent中的Executors类，可以非常容易的建立线程池。只需要将各个任务作为一个Runnable对象提交给这个线程池，就会得到一个Future对象，可以用来检查任务的进度。

    关于File，假如在磁盘上有一个文件了，你要在程序中判断这个程序存在不存在，那么你也要在程序中声明一个
    File file= new File(String parent,String filename);
    这个File是内存要用的，同样的，你要输出一个文件 ，虽然你可能已经在磁盘上建 了一个文件 ，但是还是要在程序中声明一个
    File out = new File(String pathname);
    使用输出流输出到out上
    OutputStream out = new BufferedOutputStream(new FileOutputStream(output));
    最终输出到的是文件 ，最开始读取的也是文件 。
2017-07-23
Chapter 4

Internet地址

    连接到Internet的设备称为节点(node)。计算机节点称为主机(host)。每个节点或主机都由至少一个唯一的数来标识，如果有两个网卡就两个ip，这称为Internet地址或IP地址。
    问题：局域网中的电脑在internet上是种怎样的存在呢？？这些通过路由或者交换机连接外网的电脑？？

    IPv4和IPv6是一种协议。4和6指Internet协议的版本。
    一个DNS名会映射到多个IP地址，这时就要DNS服务器负责随机选择一台机器来响应各个请求。这在流量非常大的Web网站经常使用，它将负载分摊到多个系统上。例如，www.oreilly.com实际上是两台机器，一台位于208.201.239.100，一台位于208.201.239.101上。
    域名解析是需要一个域名服务器来解析的。那么域名服务器上是在哪放着呢？在自己电脑上有一个？
    问题来了，windows中经常见到的域是什么勒？？
2017-07-24
    
        Quene队列也是一个线程？？

Chapter 5 

URL和URI
    
    URI的语法由一个模式和一个模式特定部分组成，模式和模式特定部分用一个冒号分隔，模式包括：
        data
        file:本地磁盘上的文件
        ftp:FTP服务器
        http:超文本传输协议
        mailto,magnet,telnet
    URI可以告诉你资源名，但是不能告诉你位置。
    在html中如果超链接以/开头，那么它相对于文档根目录，而不是相对于当前文件。不以/开头，则是相当于当前文件，即跟当前路径下一样的位置。根目录是服务器的根，不包含任何文件的。
    问题：输入流输出流实质都是二进制的码？是0101吗？
2017-07-25
    
    1、一直说ASCII码，那么什么是ASCII码呢？关于计算机的编码，
    2、代理服务器：代理服务器接收到从本地客户端到远程服务器的请求。代理服务器向远程服务器发出请求，再将结果转发回本地客户端。那么这个代理服务器在哪呢？在本地来中在哪？有了这个代理服务器可以防止远程主机了解本地网络配置的细节，另外也可以过滤一些出站请求。

2017-07-26

chapter 6

HTTP

此章深入后台，展示在浏览器地址栏输入网址后并按Enter时到底发生了什么?这不是正是我想要的吗？
    
    HTTP协议：
    HTTP是Web浏览器和Web服务器之间通信的标准协议。HTTP指定客户端与服务器如何建立连接、客户端如何从服务器请求数据，服务器如何响应请求，以及最后如何关闭连接。
    HTTP连接使用TCP/IP来传输数据。
    客户端请求定义了8个顶级类型：
    text 表示人可读的文字，
    image 表示图片
    application 表示二进制数据
    multipart 表示多个文档和资源的容器
    什么是Cookie？
    很多网站使用一些小文本串在连接之间存储持久的客户端状态，这些小文本串称为cookie。也就是说cookie存储在网站服务器上？？

chapter 7

URLConnection

    URLConnection类是一个抽象类。通常通过反射来进行实例化。而且对ftp等协议 不支持。
    直接使用URLConnection类的程序遵循以下步骤：
    1、构造一个URL对象
    2、调用这个URL对象的openConnection()获取一个对应该URL的URLConnection对象。
    3、配置这个URLConnection
    4、读取首部字段
    5、获得输入流并读取数据
    6、获得输出流并写入数据
    7、关闭连接

    第一次调用URLConnection时，它是未连接的。connect()方法会在本地和远程主机之间建立一个连接 。
    使用URLConnection的对象可以获取一些首部字段。
    缓存：
    Web浏览器多年来一直在缓存页面和图片。缓存到哪了呢？
    还是不明白TCP SOCKET
    有浏览器和服务器器了要javaweb这些类有什么用？

chapter 8
客户端Socket
    
    在Internet上，数据按有限大小的包传输，这些包称为数据报（datagram）